---
sidebar_position: 1
---

# Deploy Your Smart Contracts

To deploy your smart contracts to a live network, there are a few things you need to adjust.

## 1. Configure your network

Scaffold-Stark 2 comes with a selection of predefined networks: `Devnet`, `Sepolia`, and `Mainnet`.

Here are the [Starknet docs](https://docs.starknet.io/documentation/tools/api-services/) for information on Sepolia network providers.

## 2. Use pre-funded accounts and add one of them to deploy the contract(s) from.

The deployer account is the account that will deploy your contracts. Additionally, the deployer account will be used to execute any function calls that are part of your deployment script.

You can use any pre-funded account / private key or add your crypto wallet's private key.

### Configure Sepolia:

To use the Sepolia, set your own private key and configure the necessary environment variables by adding and replacing `yourWalletPrivateKey`, `yourWalletAddress` in the following:

Add the following to the `packages/snfoundry/.env` file:

If you are working with Sepolia, you need to use the setup:

```env
PRIVATE_KEY_SEPOLIA=yourWalletPrivateKey
RPC_URL_SEPOLIA=https://starknet-sepolia.public.blastapi.io/rpc/v0_8
ACCOUNT_ADDRESS_SEPOLIA=yourWalletAddress
```

### Configure Mainnet:

To use the Mainnet, set your own private key and configure the necessary environment variables by adding and replacing `yourWalletPrivateKey`, `yourWalletAddress` in the following:

Add the following to the `packages/snfoundry/.env` file:

If you are working with Mainnet, you need to use the setup:

```env
PRIVATE_KEY_MAINNET=yourWalletPrivateKey
RPC_URL_MAINNET=https://starknet-mainnet.public.blastapi.io/rpc/v0_8
ACCOUNT_ADDRESS_MAINNET=yourWalletAddress
```

## 3. Changing the smart contract name

If you decide to rename the default `YourContract` Cairo contract to something else, you will need to update the deployment script (`deploy.ts`) to use the new contract name.

### Steps to Change the Contract Name:

- **Rename the Cairo Contract**:

  Rename the `.cairo` file in the `contracts` directory to the desired name. For example, if you rename `YourContract.cairo` to `MyNewContract.cairo`, make sure the new `.cairo` file exists in the `contracts` folder.

- **Update the `deploy.ts` Script**:

  After renaming the Cairo contract file, open the `deploy.ts` script and change the contract name from `YourContract` to the new contract name you've chosen. The relevant section in the `deploy.ts` file will look like this:

  ```typescript
  const deployScript = async (): Promise<void> => {
    await deployContract({
      contract: "MyNewContract", // Change this to your renamed contract
      constructorArgs: {
        owner: deployer.address,
      },
    });
  };
  ```

- **(Optional) Deploy the same contract under a different name**:

  If you want to deploy the same contract but reference it under a different name, you can use `contractName`:

  ```typescript
  await deployContract({
    contract: "MyNewContract",
    contractName: "CustomDisplayName", // Allows multiple deployments with unique references
    constructorArgs: {
      owner: deployer.address,
    },
  });
  ```

  This can be useful if you want to:

  - Deploy multiple instances of the same contract with different identifiers.
  - Reference the deployed contract under a custom name for clarity in deployment logs.

## 4. Deploy your smart contract(s)

By default, `yarn deploy` will deploy the contract to the local network. You can change `defaultNetwork` in `scaffold.config.ts`.

Run the command below to deploy the smart contract to the target network. Make sure to have some funds in your deployer account to pay for the transaction.

```
yarn deploy --network <NETWORK_NAME>
```

e.g. `yarn deploy --network sepolia`

## Configuration of Third-Party Services for Production-Grade Apps

By default, Scaffold-Stark 2 provides predefined API keys for popular public services such as [Blast](https://blastapi.io/chains/starknet). This allows you to begin developing and testing your applications more easily, avoiding the need to register for this service.

For production-grade applications, it's recommended to obtain your own API keys (to prevent rate limiting issues). You can configure these at:

- `RPC_URL_SEPOLIA` variable in `packages/snfoundry/.env` and `packages/nextjs/.env.local`. You can create API keys from the [Alchemy dashboard](https://dashboard.alchemy.com/) or [Infura](https://www.infura.io/).

:::tip Hint
It's recommended to store environment variables for Next.js in Vercel/system environment variable configuration for live apps and use `.env.local` for local testing.
:::

## Advanced Deployment Patterns

This section provides comprehensive instructions for deploying smart contracts using the deployment scripts with more advanced scenarios.

### Deployment System Overview

The deployment system uses a `deployContract` function that handles contract deployment with configurable parameters including constructor arguments, deployment options, and gas settings.

### Single Contract Deployment

#### With Constructor Arguments

```typescript
const deployScript = async (): Promise<void> => {
  await deployContract({
    contract: "YourContract",
    contractName: "YourContractExportName", 
    constructorArgs: {
      owner: deployer.address,
      initialSupply: BigInt(1000000),
      name: "MyToken"
    },
    options: {
      maxFee: BigInt(1000000000000)
    }
  });
};
```

#### Without Constructor Arguments

```typescript
const deployScript = async (): Promise<void> => {
  await deployContract({
    contract: "SimpleContract",
    contractName: "SimpleContractExportName",
    options: {
      maxFee: BigInt(1000000000000)
    }
  });
};
```

## Multiple Contract Deployment

### Sequential Deployment

Deploy multiple contracts one after another:

```typescript
const deployMultipleContracts = async (): Promise<void> => {
  // Deploy first contract
  const tokenContract = await deployContract({
    contract: "ERC20Token",
    contractName: "MyToken",
    constructorArgs: {
      name: "MyToken",
      symbol: "MTK",
      totalSupply: BigInt(1000000000000000000000000) // 1M tokens with 18 decimals
    },
    options: {
      maxFee: BigInt(2000000000000)
    }
  });

  // Deploy second contract using first contract's address
  const stakingContract = await deployContract({
    contract: "TokenStaking",
    contractName: "StakingPool",
    constructorArgs: {
      stakingToken: tokenContract.address,
      rewardRate: BigInt(100),
      stakingDuration: 86400 // 1 day in seconds
    },
    options: {
      maxFee: BigInt(3000000000000)
    }
  });

  // Deploy third contract
  await deployContract({
    contract: "Governance",
    contractName: "TokenGovernance",
    constructorArgs: {
      token: tokenContract.address,
      votingDelay: 1,
      votingPeriod: 5760, // ~1 day in blocks
      proposalThreshold: BigInt(100000000000000000000) // 100 tokens
    },
    options: {
      maxFee: BigInt(2500000000000)
    }
  });

  console.log("All contracts deployed successfully!");
};
```

### Parallel Deployment (Independent Contracts)

For contracts that don't depend on each other:

```typescript
const deployIndependentContracts = async (): Promise<void> => {
  const deploymentPromises = [
    deployContract({
      contract: "UtilityContract",
      contractName: "Utils",
      options: {
        maxFee: BigInt(1000000000000)
      }
    }),
    
    deployContract({
      contract: "StorageContract", 
      contractName: "DataStorage",
      constructorArgs: {
        admin: deployer.address
      },
      options: {
        maxFee: BigInt(1500000000000)
      }
    }),
    
    deployContract({
      contract: "OracleContract",
      contractName: "PriceOracle",
      constructorArgs: {
        updateInterval: 3600 // 1 hour
      },
      options: {
        maxFee: BigInt(2000000000000)
      }
    })
  ];

  await Promise.all(deploymentPromises);
  console.log("All independent contracts deployed!");
};
```

## Configuration Parameters

### Required Parameters

- **`contract`**: The contract artifact name (must match your contract file name)
- **`contractName`**: The export name of your contract

### Optional Parameters

- **`constructorArgs`**: Object containing constructor parameters
- **`options`**: Deployment configuration object

### Options Object

The `options` object supports the following parameters:

```typescript
interface DeploymentOptions {
  maxFee?: bigint;           // Maximum fee willing to pay
  gasLimit?: bigint;         // Gas limit for deployment
  gasPrice?: bigint;         // Gas price
  nonce?: number;           // Transaction nonce
  // Add other options as supported by your deployment system
}
```

## Advanced Deployment Patterns

### Factory Pattern Deployment

```typescript
const deployFactorySystem = async (): Promise<void> => {
  // Deploy the factory contract first
  const factory = await deployContract({
    contract: "ContractFactory",
    contractName: "TokenFactory",
    constructorArgs: {
      feeRecipient: deployer.address,
      creationFee: BigInt(1000000000000000000) // 1 ETH
    },
    options: {
      maxFee: BigInt(3000000000000)
    }
  });

  // Deploy implementation contract
  const implementation = await deployContract({
    contract: "TokenImplementation", 
    contractName: "StandardToken",
    options: {
      maxFee: BigInt(2000000000000)
    }
  });

  console.log(`Factory deployed at: ${factory.address}`);
  console.log(`Implementation deployed at: ${implementation.address}`);
};
```

### Upgradeable Contract Deployment

```typescript
const deployUpgradeableContract = async (): Promise<void> => {
  // Deploy implementation
  const implementation = await deployContract({
    contract: "MyContractV1",
    contractName: "MyContract",
    options: {
      maxFee: BigInt(2000000000000)
    }
  });

  // Deploy proxy
  const proxy = await deployContract({
    contract: "ERC1967Proxy",
    contractName: "TransparentUpgradeableProxy",
    constructorArgs: {
      implementation: implementation.address,
      admin: deployer.address,
      data: "0x" // initialization data
    },
    options: {
      maxFee: BigInt(1500000000000)
    }
  });

  console.log(`Implementation: ${implementation.address}`);
  console.log(`Proxy: ${proxy.address}`);
};
```

## Best Practices

### 1. Gas Management

Always set appropriate gas limits and fees:

```typescript
const deployWithGasManagement = async (): Promise<void> => {
  await deployContract({
    contract: "ComplexContract",
    contractName: "MyComplexContract",
    constructorArgs: {
      // constructor args
    },
    options: {
      maxFee: BigInt(5000000000000), // Higher fee for complex contracts
      gasLimit: BigInt(8000000)      // Adequate gas limit
    }
  });
};
```

### 2. Error Handling

Implement proper error handling for production deployments:

```typescript
const deployWithErrorHandling = async (): Promise<void> => {
  try {
    const contract = await deployContract({
      contract: "RiskyContract",
      contractName: "MyContract",
      constructorArgs: {
        param1: "value1"
      },
      options: {
        maxFee: BigInt(2000000000000)
      }
    });
    
    console.log(`Contract deployed successfully at: ${contract.address}`);
    
    // Verify deployment
    if (!contract.address) {
      throw new Error("Deployment failed: No contract address returned");
    }
    
  } catch (error) {
    console.error("Deployment failed:", error);
    throw error; // Re-throw to handle at higher level
  }
};
```

### 3. Environment-Specific Deployments

```typescript
const deployForEnvironment = async (network: string): Promise<void> => {
  let maxFee: bigint;
  let constructorArgs: any;

  switch (network) {
    case 'mainnet':
      maxFee = BigInt(5000000000000);
      constructorArgs = {
        owner: "0x742d35Cc6694C0532925a3b8e5c5E9442c4888d5", // Mainnet owner
      };
      break;
    case 'testnet':
      maxFee = BigInt(1000000000000);
      constructorArgs = {
        owner: deployer.address, // Test deployer
      };
      break;
    default:
      throw new Error(`Unsupported network: ${network}`);
  }

  await deployContract({
    contract: "ProductionContract",
    contractName: "MyContract",
    constructorArgs,
    options: { maxFee }
  });
};
```

## Deployment Verification

After deployment, always verify your contracts:

```typescript
const deployAndVerify = async (): Promise<void> => {
  const contract = await deployContract({
    contract: "MyContract",
    contractName: "VerifiableContract",
    constructorArgs: {
      initialValue: 42
    },
    options: {
      maxFee: BigInt(2000000000000)
    }
  });

  // Basic verification
  console.log(`Contract deployed at: ${contract.address}`);
  console.log(`Transaction hash: ${contract.deployTransaction?.hash}`);
  
  // Wait for confirmations
  if (contract.deployTransaction) {
    const receipt = await contract.deployTransaction.wait(3); // Wait for 3 confirmations
    console.log(`Deployment confirmed in block: ${receipt.blockNumber}`);
  }
};
```

## Troubleshooting

### Common Issues

1. **Gas Estimation Failures**: Increase `gasLimit` in options
2. **Constructor Argument Mismatches**: Ensure argument types match contract constructor
3. **Insufficient Funds**: Check deployer account balance
4. **Network Connection Issues**: Verify RPC endpoint connectivity

### Debug Mode

Enable verbose logging for deployment debugging:

```typescript
const deployWithDebug = async (): Promise<void> => {
  console.log("Starting deployment...");
  
  const startTime = Date.now();
  
  const contract = await deployContract({
    contract: "DebugContract",
    contractName: "MyContract",
    constructorArgs: {
      debugMode: true
    },
    options: {
      maxFee: BigInt(2000000000000)
    }
  });
  
  const endTime = Date.now();
  console.log(`Deployment completed in ${endTime - startTime}ms`);
  console.log(`Gas used: ${contract.deployTransaction?.gasLimit}`);
};
```

## Next Steps

After successful deployment:

1. **Verify contracts** on block explorers if on public networks
2. **Update configuration files** with new contract addresses  
3. **Run integration tests** to ensure contracts work as expected
4. **Document contract addresses** for frontend integration
5. **Set up monitoring** for contract events and transactions

For more advanced deployment scenarios or troubleshooting, refer to the project's GitHub issues or contact the development team.